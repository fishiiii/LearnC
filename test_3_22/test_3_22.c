#include<stdio.h>

//数组指针大小为4/8 不管他是什么类型，函数地址传递时形参的大小是4/8 
//void print(int arr[], char arr_2[]) {
//	printf("形参arr数组的大小(byte):%d\n", sizeof(arr));
//	printf("形参arr数组的大小(byte):%d\n", sizeof(arr_2));
//}
//
//int main() {
//	int arr[] = { 1, 2, 3, 4, 5 };
//	char arr_2[] = { 'a', 'b', 'c' };
//	//int类型的数占4个字节 arr数组中包含5个数 即有20个字节
//	printf("实参arr数组的大小(byte):>%d\n", sizeof(arr));
//	//char类型的字符占1个字节 arr_2数组中包含3个字符 即有3字节
//	printf("实参arr_2数组的大小(byte):>%d\n", sizeof(arr_2));
//	print(arr, arr_2);
//	return 0;
//}

//逻辑计算 && || 
//当&&之前的表达式的值是0，那么就不会计算&&之后的表达式了
//当||之前的表达式的值是1，那么就不会计算||之后的表达式了
//int main() {
//	int a = 0;
//	int b = 1;
//	int c = 2;
//	int d = 3;
//	//这里的a++值为0，所以不用计算后面的表达式
//	//所以bd的值不变
//	int i = a++ && ++b && d++;
//	printf("a = %d, b = %d, c = %d, d = %d\n", a, b, c, d);
//	return 0;
//}

//整形提升
//当两个数的类型大小都小于int类型，生成的第三个数的类型还是小于int类型时
//如(char + char = char),那么再计算时小于int类型的值会被转换成int类型计算
//计算后的结果再进行截断，注意char类型的变量占8bit，第一个bit位是符号位
//如果char的值是负数且要补成int类型，这时补的值全是1而不是0
//int main() {
//	//00000011第一个bit位值是0代表正数，所以补后为00000000 00000000 00000000 00000011
//	char a = 3;
//	//01111111->00000000 00000000 00000000 01111111
//	char b = 127;
//	//相加后的结果是00000000 00000000 00000000 10000010
//	//截断后的结果是10000010然后存入c中
//	char c = a + b;
//	//现在要计算的是c的int行，整形提升可知11111111 11111111 11111111 10000010
//	//内存中存的是补码，且该数是负数，即反码是11111111 11111111 11111111 10000001
//	//原码位 10000000 00000000 00000000 01111110
//	//该值为-126
//	printf("%d\n", c);
//}

//验证是否会发生整形提升
//int main() {
//	char a = 1;
//	printf("%u\n", sizeof(+a)); //只要char类型进行运算，表达式的大小就是4
//	printf("%u\n", sizeof(!a)); //虽然编译器给的是1，但是再gcc下该值是4
//	return 0;
//}

//int main() {
//	char c = 0xb6;
//	short d = 0xb600;
//	int b = 0xb6000000;
//	//c与d都不会打印，因为会进行整形变换
//	if (c == 0xb6) {
//		printf("a");
//	}
//	if (d == 0xb600) {
//		printf("d");
//	}
//	if (b == 0xb6000000) {
//		printf("c");
//	}
//	return 0;
//}

//有歧义的代码
//int main() {
//	int i = 1;
//	//vs的计算方式是先算三个++i,结果是i=4,然后再进行加法得3*4=12
//	//linux的计算方式是先算前两个++i，然后再加上后面的++i。得出结果是3+3+4=10
//	int ret = (++i) + (++i) + (++i);
//	printf("%d\n", ret);
//	return 0;
//}
